<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>
// Constants
const int NUM_ELEVATORS = 2;
const int NUM_PASSENGERS = 2; 
const int MIN_FLOOR = -1;
const int MAX_FLOOR = 9; 

const int STATE_IDLE = 0;
const int STATE_MOVING_UP = 1;
const int STATE_MOVING_DOWN = 2;

const int DOORS_CLOSED = 0;
const int DOORS_OPEN = 1;
const int DOORS_OPENING = 2;
const int DOORS_CLOSING = 3;

const int TIME_DOOR_OPERATE = 1; // seconds
const int TIME_FLOOR_TRAVEL = 2; // seconds per floor
const int TIME_DOOR_OPEN_TIMEOUT = 3; // seconds to auto-close

// Types
typedef int[MIN_FLOOR, MAX_FLOOR] floor_t;
typedef int[0, NUM_ELEVATORS-1] elevator_id_t;
typedef int[0, NUM_PASSENGERS-1] passenger_id_t;
typedef int[0,1] direction_t; // 0 for DOWN, 1 for UP

// Global state variables
floor_t elevator_current_floor[elevator_id_t]; 
int elevator_state[elevator_id_t]; 
int door_state[elevator_id_t];   
bool passenger_arrived[NUM_PASSENGERS];
floor_t elevator_target_q[elevator_id_t][int[0, NUM_PASSENGERS]]; // Simplified queue: stores target floors
int elevator_q_len[elevator_id_t]; // Current length of queue

// Channels
// Passenger actions
chan make_call[passenger_id_t][floor_t][direction_t]; // pid, floor, direction
chan press_elv_button[passenger_id_t][elevator_id_t][floor_t]; // pid, eid, target_floor

// Dispatcher actions
chan assign_task[elevator_id_t][floor_t]; // eid, floor_to_go

// Elevator/Engine communication
chan request_engine_move[elevator_id_t][direction_t]; // eid, direction
chan engine_reached_floor[elevator_id_t][floor_t]; // eid, new_floor

// Elevator door signals (for passengers)
chan elv_doors_opened[elevator_id_t][floor_t]; // eid, floor
chan elv_doors_closed[elevator_id_t][floor_t]; // eid, floor

// Passenger boarding/alighting
chan try_board[passenger_id_t][elevator_id_t]; // pid, eid
chan try_alight[passenger_id_t][elevator_id_t]; // pid, eid

// Initialization function (called by templates if needed, or assume global init)
void init_elevator_queues() {
	for (i : elevator_id_t) {
		elevator_q_len[i] = 0;
	}
}
	</declaration>
	<template>
		<name>Passenger</name>
		<parameter>const passenger_id_t pid, const floor_t p_start_floor, const floor_t p_dest_floor</parameter>
		<declaration>
clock x;
elevator_id_t boarded_elevator_id;
bool call_made = false;
		</declaration>
		<location id="id0" x="0" y="0">
			<name x="-34" y="8">AtStart</name>
		</location>
		<location id="id1" x="153" y="119">
			<name x="136" y="136">Waiting</name>
		</location>
		<location id="id2" x="553" y="119">
			<name x="527" y="127">Boarding</name>
			<committed/>
		</location>
		<location id="id3" x="714" y="119">
			<name x="740" y="136">InElevator</name>
		</location>
		<location id="id4" x="996" y="120">
			<name x="986" y="110">Alighting</name>
			<committed/>
		</location>
		<location id="id5" x="997" y="0">
			<name x="987" y="-10">Arrived</name>
		</location>
		<init ref="id0"/>
		<transition id="id6">
			<source ref="id0"/>
			<target ref="id5"/>
			<label kind="guard" x="0" y="-50">p_start_floor == p_dest_floor</label>
			<label kind="assignment" x="0" y="-30">passenger_arrived[pid] = true</label>
		</transition>
		<transition id="id7">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="0" y="30">p_start_floor != p_dest_floor &amp;&amp; !call_made</label>
			<label kind="synchronisation" x="0" y="50">make_call[pid][p_start_floor][p_dest_floor &gt; p_start_floor ? 1 : 0]!</label>
			<label kind="assignment" x="0" y="70">call_made = true</label>
		</transition>
		<transition id="id8">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="select" x="195" y="153">eid : elevator_id_t</label>
			<label kind="synchronisation" x="195" y="119">elv_doors_opened[eid][p_start_floor]?</label>
			<label kind="assignment" x="195" y="136">boarded_elevator_id = eid, x=0</label>
		</transition>
		<transition id="id9">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="595" y="119">try_board[pid][boarded_elevator_id]!</label>
			<label kind="assignment" x="595" y="139">x=0</label>
		</transition>
		<transition id="id10">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="714" y="184">x &lt; 1</label>
			<label kind="synchronisation" x="714" y="204">press_elv_button[pid][boarded_elevator_id][p_dest_floor]!</label>
			<nail x="718" y="178"/>
			<nail x="748" y="178"/>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="739" y="85">elv_doors_opened[boarded_elevator_id][p_dest_floor]?</label>
			<label kind="assignment" x="739" y="105">x=0</label>
		</transition>
		<transition id="id12">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="969" y="34">try_alight[pid][boarded_elevator_id]!</label>
			<label kind="assignment" x="969" y="17">passenger_arrived[pid] = true</label>
		</transition>
	</template>
	<template>
		<name>Engine</name>
		<parameter>const elevator_id_t eid</parameter>
		<declaration>
clock t_travel;
direction_t current_direction; // Changed from bool
bool active = false;
		</declaration>
		<location id="id13" x="-110" y="0">
			<name x="-136" y="17">Idle</name>
		</location>
		<location id="id14" x="544" y="0">
			<name x="560" y="-15">Moving</name>
			<label kind="invariant" x="561" y="0">t_travel &lt;= TIME_FLOOR_TRAVEL</label>
		</location>
		<init ref="id13"/>
		<transition id="id15">
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="select" x="-8" y="-62">d_param : direction_t</label>
			<label kind="synchronisation" x="-8" y="-42">request_engine_move[eid][d_param]?</label>
			<label kind="assignment" x="-8" y="-22">current_direction = d_param, t_travel = 0, active = true</label>
		</transition>
		<transition id="id16">
			<source ref="id14"/>
			<target ref="id13"/>
			<label kind="guard" x="127" y="252">t_travel &gt;= TIME_FLOOR_TRAVEL &amp;&amp; active</label>
			<label kind="synchronisation" x="127" y="272">engine_reached_floor[eid][elevator_current_floor[eid] + (current_direction == 1 ? 1 : -1)]!</label>
			<label kind="assignment" x="127" y="289">active=false</label>
			<nail x="223" y="251"/>
		</transition>
	</template>
	<template>
		<name>Elevator</name>
		<parameter>const elevator_id_t eid</parameter>
		<declaration>
clock clk_d; // door clock
floor_t current_target_floor;
bool has_request = false;
direction_t move_dir; // Changed from bool

// Simplified queue management
void add_to_queue(floor_t f) {
    if (elevator_q_len[eid] &lt; NUM_PASSENGERS + 1) {
        bool already_exists = false;
        for (i : int[0, NUM_PASSENGERS]) {
            if (i &lt; elevator_q_len[eid]) {
                if (elevator_target_q[eid][i] == f) {
                    already_exists = true;
                }
            }
        }
        if (!already_exists) {
            elevator_target_q[eid][elevator_q_len[eid]] = f;
            elevator_q_len[eid]++;
        }
    }
}

void process_next_target() {
    if (elevator_q_len[eid] &gt; 0) {
        if (!has_request) { // Only pick a new target if not already handling one
            current_target_floor = elevator_target_q[eid][0];
            has_request = true;

            // Pop item from queue by shifting elements.
            // If elevator_q_len[eid] is 1, no shift is needed (outer if elevator_q_len[eid] &gt; 1 handles this).
            // If elevator_q_len[eid] &gt; 1, shift elements.
            if (elevator_q_len[eid] &gt; 1) { // Loop only if there are at least two elements to perform a shift
                // Iterate with a static upper bound (NUM_PASSENGERS)
                // and use a conditional check against the dynamic elevator_q_len[eid].
                // j_iter represents the source index of the element to be shifted.
                for (j_iter : int[1, NUM_PASSENGERS]) { 
                    // Only perform the shift if j_iter is a valid index within the current queue length.
                    // The elements to shift are from index 1 to elevator_q_len[eid] - 1.
                    if (j_iter &lt;= elevator_q_len[eid] - 1) {
                        elevator_target_q[eid][j_iter-1] = elevator_target_q[eid][j_iter];
                    }
                }
            }
            // elevator_target_q[eid][elevator_q_len[eid]-1] = 0; // Optional: Clear last if needed (after decrementing q_len)
            elevator_q_len[eid]--; // Decrement length after taking the first element

            // Determine move_dir
            if (current_target_floor &gt; elevator_current_floor[eid]) {
                move_dir = 1; // UP
            } else if (current_target_floor &lt; elevator_current_floor[eid]) {
                move_dir = 0; // DOWN
            }
            // If current_target_floor == elevator_current_floor[eid], move_dir is not set here;
            // has_request is true, so Idle_DClosed -&gt; D_Opening transition should handle it.
        }
        // If has_request was already true, do nothing more here; continue with current request.
        // The new item (if any) was added to queue by add_to_queue() and will be picked up
        // when process_next_target() is called after the current request is serviced.
    } else { // Queue is empty
        has_request = false; // No more requests
    }
}
		</declaration>
		<location id="id17" x="0" y="0">
			<name x="-50" y="-10">Idle_DClosed</name>
			<label kind="invariant" x="-50" y="10">door_state[eid] == DOORS_CLOSED &amp;&amp; elevator_state[eid] == STATE_IDLE</label>
		</location>
		<location id="id18" x="-892" y="-8">
			<name x="-954" y="-9">Moving</name>
		</location>
		<location id="id19" x="492" y="-491">
			<name x="442" y="-501">D_Opening</name>
			<label kind="invariant" x="442" y="-481">clk_d &lt;= TIME_DOOR_OPERATE</label>
		</location>
		<location id="id20" x="935" y="416">
			<name x="961" y="391">D_Open</name>
			<label kind="invariant" x="915" y="426">clk_d &lt;= TIME_DOOR_OPEN_TIMEOUT</label>
		</location>
		<location id="id21" x="-93" y="442">
			<name x="-118" y="465">D_Closing</name>
			<label kind="invariant" x="-143" y="452">clk_d &lt;= TIME_DOOR_OPERATE</label>
		</location>
		<init ref="id17"/>
		<transition id="id22">
			<source ref="id17"/>
			<target ref="id17"/>
			<label kind="select" x="-239" y="-210">f_param : floor_t</label>
			<label kind="synchronisation" x="-239" y="-190">assign_task[eid][f_param]?</label>
			<label kind="assignment" x="-239" y="-170">add_to_queue(f_param), process_next_target()</label>
			<nail x="-119" y="-170"/>
			<nail x="-59" y="-170"/>
		</transition>
		<transition id="id23">
			<source ref="id17"/>
			<target ref="id17"/>
			<label kind="select" x="-535" y="153">p_id_sel : passenger_id_t, f_param : floor_t</label>
			<label kind="synchronisation" x="-535" y="173">press_elv_button[p_id_sel][eid][f_param]?</label>
			<label kind="assignment" x="-535" y="193">add_to_queue(f_param), process_next_target()</label>
			<nail x="-415" y="93"/>
			<nail x="-357" y="127"/>
		</transition>
		<transition id="id24">
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="guard" x="-42" y="-280">has_request &amp;&amp; elevator_current_floor[eid] == current_target_floor</label>
			<label kind="assignment" x="-42" y="-297">door_state[eid] = DOORS_OPENING, clk_d = 0, has_request=false /*serviced*/</label>
		</transition>
		<transition id="id25">
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="guard" x="-1054" y="62">has_request &amp;&amp; elevator_current_floor[eid] != current_target_floor</label>
			<label kind="synchronisation" x="-1054" y="82">request_engine_move[eid][move_dir]!</label>
			<label kind="assignment" x="-1054" y="102">elevator_state[eid] = (move_dir == 1 ? STATE_MOVING_UP : STATE_MOVING_DOWN)</label>
			<nail x="-484" y="68"/>
		</transition>
		<transition id="id26">
			<source ref="id18"/>
			<target ref="id17"/>
			<label kind="select" x="-816" y="-130">f_param : floor_t</label>
			<label kind="guard" x="-816" y="-90">f_param == current_target_floor</label>
			<label kind="synchronisation" x="-816" y="-110">engine_reached_floor[eid][f_param]?</label>
			<label kind="assignment" x="-816" y="-70">elevator_current_floor[eid] = f_param, elevator_state[eid] = STATE_IDLE</label>
		</transition>
		<transition id="id27">
			<source ref="id18"/>
			<target ref="id18"/>
			<label kind="select" x="-1224" y="-142">f_param : floor_t</label>
			<label kind="guard" x="-1224" y="-102">f_param != current_target_floor</label>
			<label kind="synchronisation" x="-1224" y="-62">request_engine_move[eid][move_dir]!</label>
			<label kind="assignment" x="-1224" y="-82">elevator_current_floor[eid] = f_param</label>
			<nail x="-922" y="-38"/>
			<nail x="-862" y="-38"/>
		</transition>
		<transition id="id28">
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="guard" x="782" y="82">clk_d &gt;= TIME_DOOR_OPERATE</label>
			<label kind="synchronisation" x="782" y="122">elv_doors_opened[eid][elevator_current_floor[eid]]!</label>
			<label kind="assignment" x="782" y="102">door_state[eid] = DOORS_OPEN, clk_d = 0</label>
		</transition>
		<transition id="id29">
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="guard" x="340" y="396">clk_d &gt;= TIME_DOOR_OPEN_TIMEOUT</label>
			<label kind="assignment" x="340" y="416">door_state[eid] = DOORS_CLOSING, clk_d = 0</label>
		</transition>
		<transition id="id30">
			<source ref="id20"/>
			<target ref="id20"/>
			<label kind="select" x="715" y="478">p_id_board : passenger_id_t</label>
			<label kind="synchronisation" x="715" y="498">try_board[p_id_board][eid]?</label>
			<label kind="assignment" x="715" y="518">clk_d = 0</label>
			<nail x="765" y="478"/>
			<nail x="765" y="518"/>
		</transition>
		<transition id="id31">
			<source ref="id20"/>
			<target ref="id20"/>
			<label kind="select" x="1080" y="478">p_id_alight : passenger_id_t</label>
			<label kind="synchronisation" x="1080" y="498">try_alight[p_id_alight][eid]?</label>
			<label kind="assignment" x="1080" y="518">clk_d = 0</label>
			<nail x="1130" y="478"/>
			<nail x="1130" y="518"/>
		</transition>
		<transition id="id32">
			<source ref="id21"/>
			<target ref="id17"/>
			<label kind="guard" x="-340" y="269">clk_d &gt;= TIME_DOOR_OPERATE</label>
			<label kind="synchronisation" x="-340" y="289">elv_doors_closed[eid][elevator_current_floor[eid]]!</label>
			<label kind="assignment" x="-340" y="309">door_state[eid] = DOORS_CLOSED, clk_d = 0, has_request = false, process_next_target() /* Service complete, now check queue */</label>
		</transition>
	</template>
	<template>
		<name>Dispatcher</name>
		<declaration>
floor_t pending_call_floor;
direction_t pending_call_direction; // Uses new direction_t (int[0,1])
passenger_id_t pending_caller_pid;
bool has_pending_call = false;
		</declaration>
		<location id="id33" x="-102" y="0">
			<name x="-112" y="-30">Idle</name>
		</location>
		<location id="id34" x="476" y="17">
			<name x="466" y="-13">Assigning</name>
			<committed/>
		</location>
		<init ref="id33"/>
		<transition id="id35">
			<source ref="id33"/>
			<target ref="id34"/>
			<label kind="select" x="187" y="-286">pid_sel : passenger_id_t, f_sel : floor_t, d_sel : direction_t</label>
			<label kind="guard" x="187" y="-306">!has_pending_call</label>
			<label kind="synchronisation" x="187" y="-266">make_call[pid_sel][f_sel][d_sel]?</label>
			<label kind="assignment" x="187" y="-246">pending_caller_pid = pid_sel, pending_call_floor = f_sel, pending_call_direction = d_sel, has_pending_call = true</label>
			<nail x="153" y="-236"/>
		</transition>
		<transition id="id36">
			<source ref="id34"/>
			<target ref="id33"/>
			<label kind="select" x="195" y="252">eid_sel : elevator_id_t</label>
			<label kind="guard" x="195" y="232">has_pending_call</label>
			<label kind="synchronisation" x="195" y="272">assign_task[eid_sel][pending_call_floor]!</label>
			<label kind="assignment" x="195" y="289">has_pending_call = false</label>
			<nail x="161" y="297"/>
		</transition>
	</template>
	<system>
// Initialize global arrays (UPPAAL does this implicitly for basic types to 0/false)
// elevator_current_floor = {1, 1}; // Example: Both start at floor 1
// passenger_arrived = {false, false};
// init_elevator_queues(); // Call if complex init needed in declaration, not standard UPPAAL

// Instantiate one of each component
E0 = Elevator(0);
E1 = Elevator(1);
Eng0 = Engine(0); // Engine for Elevator 0
Eng1 = Engine(1); // Engine for Elevator 1
D = Dispatcher();
// MODIFIED: Instantiate Passengers with pid, start_floor, dest_floor
P1 = Passenger(0, 3, 8); // Passenger 0: floor 3 to 8
P2 = Passenger(1, 9, -1); // Passenger 1: floor 9 to -1

// Add components to the system
system E0, E1, Eng0, Eng1, D, P1, P2;
	</system>
	<queries>
		<option key="--diagnostic" value="2"/>
		<query>
			<formula>A[] not (elevator_state[0] != STATE_IDLE and door_state[0] == DOORS_OPEN) and not (elevator_state[1] != STATE_IDLE and door_state[1] == DOORS_OPEN)</formula>
			<comment>Safety: An elevator never moves with its doors open.</comment>
			<result outcome="success" type="quality" timestamp="2025-06-06 17:35:58 +0800">
			</result>
		</query>
		<query>
			<formula>A[] forall(i : elevator_id_t) not (elevator_state[i] != STATE_IDLE and door_state[i] == DOORS_OPEN)</formula>
			<comment>Safety: Doors are not open while the elevator is moving.</comment>
			<result outcome="success" type="quality" timestamp="2025-06-06 17:36:00 +0800">
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; passenger_arrived[0] and passenger_arrived[1]</formula>
			<comment>Liveness: It is possible for all passengers to reach their destinations.</comment>
			<result outcome="failure" type="quality" timestamp="2025-06-06 17:36:59 +0800">
			</result>
		</query>
		<query>
			<formula>A&lt;&gt; passenger_arrived[0]</formula>
			<comment>Liveness: Passenger 1 eventually reaches their destination.</comment>
			<result outcome="failure" type="quality" timestamp="2025-06-06 17:36:02 +0800">
			</result>
		</query>
		<query>
			<formula>A[] not deadlock</formula>
			<comment>Check for deadlocks in the system.</comment>
			<result outcome="failure" type="quality" timestamp="2025-06-07 02:08:33 +0800">
				<option key="--diagnostic" value="2"/>
			</result>
		</query>
	</queries>
</nta>
